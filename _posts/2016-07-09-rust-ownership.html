---
title: "What is Ownership in Rust?"
layout: post
---
<p>
  My friend <a href="https://github.com/malisas">Malisa</a> and I have
  been hacking on Servo this summer. We started from scratch, i.e. no
  experience with Rust let alone compiled langauges, and it's
  been challenging and fun. One of the trickier Rust concepts to
  understand for me was Rust's references and
  borrowing, which I'll write about today.
</p>

<p>
Ownership in Rust is in many ways like owning a coloring book. You can
lend it to your friends to look at the coloring book under the
condition of never coloring it, or "immutably borrow" in Rust
lingo. This is because if your friends were allowed to color, it would
forever change the coloring book, and you will never be able to color
it the way you want.
</p>

<p>But say you are a very nice person and/or actually want to create a
collective art piece with the coloring book. You can lend it to one
friend at a time and tell them they can color however they want, or
"mutably borrow" in Rust lingo. You'll ask them to give the book back
to you afterwards, and then you may lend it to another person, and so on*.
</p>

<p> Rust's default of borrowing is borrowing the object to just to
have a look at it. In our coloring book example, this would be like
your friends gathering around and looking at the coloring book, but
never coloring it. Similarly, in Rust, anything that is borrowed,
unless specified, is immutable (i.e. no coloring is allowed).
</p>

<p> Relatedly, if you want to allow the object to be modified, you can
let others borrow mutably, but only one entity can do so at a time. In
the coloring book example, it means that you can lend it to a single
friend who wants to color at a time. And the reason is quite
straightforward -- imagine how chaotic it would be if more than two
friends wanted to color the same page differently.
</p>

<p>In both cases, if the lender wants to color the book, then they
must get it back from the borrower first. How else would you color a
book you don't have in your hands?!</p>

<p><a href="http://words.steveklabnik.com/">Steve Klabnik</a>, the author of "The Book", wrote an
awesome <a href="https://doc.rust-lang.org/book/references-and-borrowing.html">introduction</a>
to the Rust's borrow system, and this blog post was inspired by
<a href="https://doc.rust-lang.org/book/references-and-borrowing.html#mut-references">one of its examples</a>.
Based on my limited experience with compiled language,
I think making compiler fail and reading its messages (especially when
the compiler gives detailed explanation like in Rust) is a helpful way
to understand newer concepts! So I branched off his example,
and tried to break things!! How fun!!! I still <strike>sometimes</strike> often
fight the Rust compiler's borrow checker, but a couple hours of making
compiler fail definitely helped me understand the concept. So let's
start with something simple that compiles.</p>

{% highlight rust %}
fn main() {
    let mut x = 5;
    let mut y = x;        // the compiler makes a copy of `x` and assigns to `y`

    y += 1;

    println!("{}", x);
    println!("{}", y);
}
{% endhighlight %}
<a href="https://is.gd/hE79YV">Link to code</a>, and its compilation message:
{% highlight bash %}
warning: variable does not need to be mutable, #[warn(unused_mut)] on by default
 --> <anon>:2:9
2 |>     let mut x = 5;
  |>         ^^^^^

x is: 5
y is: 6
{% endhighlight %}

<p> This particular
example involves numeric types, which is one
of <a href="https://doc.rust-lang.org/book/primitive-types.html">primitive
types</a>. If you want a refresher on primitive types, this might be a
good time to review it. While it's not obvious, by <code>let mut y =
x</code>, the compiler actually makes a copy of <code>x</code> and
mutably assigns it to <code>y</code>. <code>x</code>
and <code>y</code> point to two different things in the memory as you
can tell by how the printed values are different! The compiler will
warn that <code>x</code> didn't have to be mutable, but we'll ignore
  that for now. So far so good. Let's now break this code!</p>

{% highlight rust %}
fn main() {
    let mut x = 5;
    let mut y = &x;       // `y` gets an *immutable* reference to mutable `x`

    *y += 1;              // dereferenced `y` gets incremented by 1

    println!("y is: {}", y);
}
{% endhighlight %}
<a href="https://is.gd/Jt93zQ">Link to code</a>, and its compilation message:
{% highlight bash %}
error: cannot assign to immutable borrowed content `*y`
 --> <anon>:5:5
5 |>     *y += 1;              // dereferenced `y` gets incremented by 1
  |>     ^^^^^^^

error: aborting due to previous error
{% endhighlight %}

<p> What happened?
Unlike copying and getting ownership in the previous example, in this
example, <code>y</code> got a reference to <code>x</code>. Before 1 is
added to <code>y</code>, it had to be dereferenced
because <code>y</code> is only a reference. One important thing to
note is that <code>y</code> got an <b>immutable</b> reference, even
though <code>y</code> itself is mutable! That is why the compiler
throws an error at the end. <code>y</code> didn't have the permission
to change the value, yet it tried to do so.  Let's now fix this
code. Make the compiler happy again!</p>

{% highlight rust %}
fn main() {
    let mut x = 5;
    let mut y = &mut x;   // `y` gets a *mutable* reference to mutable `x`

    *y += 1;              // dereferenced `y` gets incremented by 1

    println!("y is: {}", y);
}
{% endhighlight %}
<a href="https://is.gd/yW8Yhx">Link to code</a>, and its compilation message:
{% highlight bash %}
y is: 6
{% endhighlight %}

<p>
Now, <code>y</code> got an explicit permission from <code>x</code>
that it can change the value it borrowed. So when we try to
print <code>y</code> it successfully prints 6. Now, what happens if we
try to print <code>x</code> instead? This brings us
to <a href="https://doc.rust-lang.org/book/references-and-borrowing.html#thinking-in-scopes">one</a>
of the Book's examples.</p>

{% highlight rust %}
fn main() {
    let mut x = 5;
    let mut y = &mut x;   // `x` gets mutably borrowed here

    *y += 1;

    println!("x is: {}", x);
}
{% endhighlight %}
<a href="https://is.gd/X2ufGa">Link to code</a>, and its compilation message:
{% highlight bash %}
error: cannot borrow `x` as immutable because it is also borrowed as mutable [--explain E0502]
   --> <anon>:7:26
3   |>     let mut y = &mut x;   // `x` gets mutably borrowed here
    |>                      - mutable borrow occurs here
...
7   |>     println!("x is: {}", x);
    |>                          ^ immutable borrow occurs here
8   |> }
    |> - mutable borrow ends here
<std macros>:2:27: 2:58: note: in this expansion of format_args!
<std macros>:3:1: 3:54: note: in this expansion of print! (defined in <std macros>)
<anon>:7:5: 7:29: note: in this expansion of println! (defined in <std macros>)

error: aborting due to previous error
{% endhighlight %}

<p>Compilation
fails! The compiler gives a pretty good explanation. It says that
it cannot borrow <code>x</code> as immutable because it is also
borrowed as mutable. <code>x</code> was mutably rented out
by <code>y</code> and the print statement tried to borrow it too. This
violates the rule of Rust's borrow system -- only one can mutably
borrow, or many can immutably borrow. The Book also
shows <a href="https://doc.rust-lang.org/book/references-and-borrowing.html#mut-references">a
way</a> to correct this code by using curly brackets like below.

{% highlight rust %}
fn main() {
    let mut x = 5;
    {
        let y = &mut x;
        *y += 1;
    }
    println!("x is: {}", x);
}
{% endhighlight %}
<a href="https://is.gd/4Razar">Link to code</a>, and its compilation message:
{% highlight bash %}
x is: 6
{% endhighlight %}

<p> The Book does a
better job in explaining scopes than I can, so I highly recommend
reading <a href="https://doc.rust-lang.org/book/references-and-borrowing.html#thinking-in-scopes">the
Book</a> about this section. Let's break this code again one last
time.</p>

{% highlight rust %}
fn main() {
    let mut x = 5;
    {
        let y = &mut x;
        *y += 1;
    }
    println!("y is: {}", y);
}
{% endhighlight %}
<a href="https://is.gd/BffVNx">Link to code</a>, and its compilation message:
{% highlight bash %}
error: unresolved name `y`. Did you mean `x`? [--explain E0425]
 --> <anon>:7:26
7 |>     println!("y is: {}", y);
  |>                          ^
<std macros>:2:27: 2:58: note: in this expansion of format_args!
<std macros>:3:1: 3:54: note: in this expansion of print! (defined in <std macros>)
<anon>:7:5: 7:29: note: in this expansion of println! (defined in <std macros>)

error: aborting due to previous error
{% endhighlight %}

<p>The compiler
fails to understand what <code>y</code> is. This is
because <code>y</code> is defined inside curly brackets, and outside
of them, <code>y</code> doesn't exist! This feature gets very handy
when you want to define things only temporarily.</p>

<p>Now you should go break some codes! Thanks for reading!</p>

<small>*Or maybe you'll give the book to your friend forever, in which case
you're giving away your ownership, but we won't cover that concept in
this blog post.</smaller>
